
enum type_let {
    FOO,
    BAR,
}

type_let::FOO

fn alloc<T>(n: usize) -> [T] {

}

fn sum(values: [u64]) -> u64 {
    let sum: u64 = 0;
    for let i: usize = 0; i < values.len; i += 1 {
        sum += *(values.ptr + i);
    }
    sum
}



fn strcat(a: slice, b: slice) -> slice {
    let new: &u8 = malloc(a.size + b.size);
    memcpy(new, a.ptr, a.size);
    memcpy(new + a.size, b.ptr, b.size);
    new
}

struct foo {
    arr: [u32; 10],
    fn_ptr: &fn(i32) -> i32,
}

fn malloc(n: usize) -> &void {
    ...
}

fn malloc(n: usize) -> (u32, u32) {
    ...
}

fn openfile(filename: slice) -> (fp, &err) {
    ...
}

fn free(p: &void)

fn panic() -> ! {
    loop {}
}

fn associated_function(c: &foo) {
    c->a = 3;
}

fn take_struct(s: foo) -> foo {
    a.a = 1;
    s.b = 2; 
    s
}

fn take_struct_by_pointer(s: &foo) -> void {
    a = 1;
    s->b = 2; 
}

struct custom {
    val: u64
}

fn ::std::ops::hash<custom>(val: custom) -> u64 {
    std::ops::hash()
}


struct<T> slice<T> {
    ptr: &T;
    len: usize;
    
    fn new(len: usize) -> {
        slice<T> {
            ptr: ::_jemalloc::malloc(size_of::<T>() * size) as &T
        }
    }

    fn range(self, start: usize, stop: usize) -> slice<T> {
        slice<T> {
            ptr: self.ptr + start,
            len: stop - start 
        }
    }

    fn free(self) {
        ::_jemalloc::free(self.ptr)
    }
}

struct inner_arc<T> {
    data: T,
    ref_count: usize
}

mod sync {

    struct arc<T> {
        ptr: &(T, usize);

        fn new(data: T) -> arc<T> {
            let ptr = ::_jemalloc::malloc(size_of::<(T, usize)>()) as &(T, usize)
            *ptr = (data, 1)
            arc<T> { ptr: ptr }
        } 

        fn get() -> &T {
            &self.ptr.0
        }

        fn clone(self) -> arc<T> {
            self.ptr.1 += 1;
            self
        }

        fn free(&self) {
            self.ptr.1 -= 1;
            if self.ptr.1 == 0 {
                ::_jemalloc::free(self.ptr)
            }
        }
    }

}

struct vector<T> {
    data: [T];
    capacity: usize;

    fn new(capacity: usize) -> vector<T> {
        vector::<T> {
            data: slice::<T> {
                ptr: malloc(size_of::<T>() * capacity),
                len: 0,
            },
            capacity: capacity,
        }
    }
}

fn main() {
    let vector = vector::<u8>::new(10);
    vector.append(0x00);
    vector.append(0x01);
    vector.append(0x02);
    vector.data[i] = 0x03;

    vector.free();
}


fn main() {
    let a: &u32;
    let b: [u8; 5] = { 1, 2, 3, 4, 5 };

    // arrays coerce to slices, so they can be passed to functions that take slices
    

    *(0x3282379823 as &u8) = 15;

    let foo, bar: &u32;

    a = {
        let c: &u32;
        c + 1
    };

    a = &b[0];

    let (fp, err) = openfile("foo.txt");
    if err != nil {

    }

    let ptr = &take_struct_by_pointer;

    let f: foo;
    f.a = 1;
    f.b = 2;

    f.associated_function();
    
    for a = 0, a < 15, a += 1 {
        b[i] = 1;
    }
}
