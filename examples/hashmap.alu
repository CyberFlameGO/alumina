

struct hashmap<K, V, EqualityComparer> {
    buckets: vector<vector<(K, V)>>,
}


impl vector {
    fn new() -> vector<T> {
        with_capacity::<T>(0)
    }

    fn with_capacity<T>(capacity: usize) -> vector<T> {
        vector<T> {
            buckets: vector::new::<vector<(K,V)>>(),
        }
    }

    fn push<T>(self: &vector<T>, value: T) {
        if self.length == self.capacity {
            let new_capacity = self.capacity * 2;
            let new_ptr = malloc(sizeof(T) * new_capacity) as &T;
            memcpy(new_ptr, self.data, self.length);
            free(self.data);
            self.data = new_ptr;
            self.capacity = new_capacity;
        }

        self.data[self.length] = value;
        self.length += 1;
    }

    fn pop<T>(self: &vector<T>) -> T {
        let value = self.data[self.length - 1];
        self.length -= 1;
        value
    }

    fn shrink_to_fit<T>(self: &vector<T>) {
        if self.length < self.capacity {
            let new_capacity = self.length;
            let new_ptr = malloc(sizeof(T) * new_capacity) as &T;
            memcpy(new_ptr, self.data, self.length);
            free(self.data);
            self.data = new_ptr;
            self.capacity = new_capacity;
        }
    }

    fn index<T>(self: &vector<T>, index: usize) -> &T {
        self.data + index
    }

    fn free<T>(self: &vector<T>) {
        free(self.data);
    }
}



fn main() {
    let mut v = vector::new::<u8>();
    v.push(1);
    v.free();
}


