mod mem {
    fn malloc(size: usize) -> &() { loop{} }
    fn free<T>(ptr: &T) { loop{} }
    fn sizeof() -> usize { loop{} }
    fn memcpy<T>(a: &T, b: &T, len: usize) -> usize { loop{} }
}

fn sizeof<T>() -> usize {
    loop{}
}

struct vector<T> {
    data: &T,
    length: usize,
    capacity: usize,
}


impl vector {
    use mem::{memcpy, malloc};

    fn new<T>() -> vector<T> {
        with_capacity(0)
    }

    fn with_capacity<T>(capacity: usize) -> vector<T> {
        vector {
            data: malloc(sizeof::<T>() * capacity) as &T,
            length: 0,
            capacity: capacity,
        }
    }

    fn push<T>(self: &vector<T>, value: T) {
        if self.length == self.capacity {
            let new_capacity = self.capacity * 2;
            let new_ptr = malloc(sizeof::<T>() * new_capacity) as &T;
            memcpy(new_ptr, self.data, self.length);
            mem::free(self.data);
            self.data = new_ptr;
            self.capacity = new_capacity;
        }

        self.data[self.length] = value;
        self.length += 1;
    }

    fn pop<T>(self: &vector<T>) -> T {
        let value = self.data[self.length - 1];
        self.length -= 1;
        value
    }

    fn shrink_to_fit<T>(self: &vector<T>) {
        if self.length < self.capacity {
            let new_capacity = self.length;
            let new_ptr = malloc(sizeof::<T>() * new_capacity) as &T;
            memcpy(new_ptr, self.data, self.length);
            free(self.data);
            self.data = new_ptr;
            self.capacity = new_capacity;
        }
    }

    fn index<T>(self: &vector<T>, index: usize) -> &T {
        self.data + index
    }

    fn free<T>(self: &vector<T>) {
        mem::free(self.data);
    }
}



fn main() {
    let v = vector::new::<u8>();
    v.push(1);
    v.free();
}
