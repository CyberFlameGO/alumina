
mod proto {
    // These are built-in marker protocols that cannot be implemented by user code,
    // even though they contain no associated functions. They are handled specially
    // by the compiler.
    #[lang(proto_any)] protocol Any {}
    #[lang(proto_primitive)] protocol Primitive {}
    #[lang(proto_numeric)] protocol Numeric {}
    #[lang(proto_integer)] protocol Integer {}
    #[lang(proto_floating_point)] protocol FloatingPoint {}
    #[lang(proto_signed)] protocol Signed {}
    #[lang(proto_unsigned)] protocol Unsigned {}
    #[lang(proto_pointer)] protocol Pointer {}
}

mod mem {
    use proto::Pointer;
    use std::result::Option;

    #[lang(slice)]
    struct slice<Ptr: Pointer> {
        ptr: Ptr,
        len: usize,
    }

    impl slice {
        use std::cmp::{Equatable, Comparable, Ordering};
        use std::hash::{Hasher};
        use std::proto::Primitive;
        use std::libc::{memcmp};

        #[force_inline]
        #[lang(slice_new)]
        fn from_raw<Ptr: Pointer>(ptr: Ptr, len: usize) -> slice<Ptr> {
            slice::<Ptr> { ptr: ptr, len: len }
        }

        #[force_inline]
        fn iter<Ptr: Pointer>(self: slice<Ptr>) -> slice<Ptr> {
            self
        }

        #[force_inline]
        fn next<Ptr: Pointer>(self: &mut slice<Ptr>) -> Option<Ptr> {
            if self.len > 0 {
                let result = Option::some(self.ptr);
                self.ptr = self.ptr + 1;
                self.len -= 1;
                result
            } else {
                Option::none()
            }
        }

        // Equality and ordering comparison are implemented only for slices of 
        // primitive types.
        fn equals<T: Primitive>(lhs: &&[T], rhs: &&[T]) -> bool {
            if lhs.len != rhs.len {
                return false;
            }
            memcmp(lhs.ptr as &void, rhs.ptr as &void, lhs.len * size_of::<T>()) == 0
        }

        fn compare<T: Primitive>(lhs: &&[T], rhs: &&[T]) -> Ordering {
            use std::math::min;

            let cmp = memcmp(lhs.ptr as &void, rhs.ptr as &void, min(lhs.len, rhs.len) * size_of::<T>());

            if cmp < 0 {
                Ordering::Less
            } else if cmp > 0 {
                Ordering::Greater
            } else {
                if lhs.len < rhs.len {
                    Ordering::Less
                } else if lhs.len > rhs.len {
                    Ordering::Greater
                } else {
                    Ordering::Equal
                }
            }
        }
        
        fn hash<T: Primitive, H: Hasher<H>>(self: &&[T], hasher: &mut H) {
            hasher.write(from_raw(self.ptr as &u8, self.len * size_of::<T>()));
        }

        fn fmt<F: fmt::Formatter<F>>(self: &&[u8], f: &mut F) {
            f.write(*self);
        }
        
        mixin<T: Primitive> Equatable<slice<&T>>;
        mixin<T: Primitive> Comparable<slice<&T>>;
    }

    mod internal {
        use proto::{Primitive, Pointer}; 
        
        #[force_inline]
        #[lang(slice_index)]
        fn slice_index<Ptr: Pointer>(a: slice<Ptr>, idx: usize) -> Ptr {
            a.ptr + idx
        }
        
        #[force_inline]
        #[lang(slice_range_index)]
        fn slice_range_index<Ptr: Pointer>(a: slice<Ptr>, lower: usize, upper: usize) -> slice<Ptr> {
            slice::from_raw::<Ptr>(a.ptr + lower, upper - lower)
        }

        #[force_inline]
        #[lang(slice_range_index_lower)]
        fn slice_range_index_lower<Ptr: Pointer>(a: slice<Ptr>, lower: usize) -> slice<Ptr> {
            slice::from_raw::<Ptr>(a.ptr + lower, a.len - lower)
        }        

        #[force_inline]
        #[lang(slice_coerce)]
        fn slice_coerce<T>(a: slice<&mut T>) -> slice<&T> {
            slice::from_raw::<&T>(a.ptr, a.len)
        }
    }
    
    fn alloc<T>(len: usize) -> &mut [T] {
        let ret: &mut [T];
        ret.ptr = libc::malloc(size_of::<T>() * len) as &mut T;
        ret.len = len;
        ret
    }

    fn alloc_zeroed<T>(len: usize) -> &mut [T] {
        let ret: &mut [T];
        ret.ptr = libc::calloc(len, size_of::<T>()) as &mut T;
        ret.len = len;
        ret
    }

    #[force_inline]
    fn stack_alloc<T>(len: usize) -> &mut [T] {
        // TODO: this is broken until inlining in IR is implemented, since __builtin_alloca_with_align
        // cannot leave the function it was called in even if the function was force-inlined.
        let ret: &mut [T];
        ret.ptr = intrinsics::aligned_alloca(
            size_of::<T>() * len, 
            if intrinsics::align_of::<T>() >= 8 {
                intrinsics::align_of::<T>()
            } else { 
                8usize 
            }
        ) as &mut T;
        ret.len = len;
        ret
    }

    #[force_inline]
    fn size_of<T>() -> usize {
        intrinsics::size_of::<T>()
    }

    #[force_inline]
    fn align_of<T>() -> usize {
        intrinsics::align_of::<T>()
    }

    fn swap<T>(a: &mut T, b: &mut T) {
        let tmp = *a;
        *a = *b;
        *b = tmp;
    }

    fn replace<T>(a: &mut T, b: T) -> T {
        swap(a, &b);
        b
    }

    fn copy_to_nonoverlapping<T>(src: &[T], dst: &mut T) {
        libc::memcpy(dst as &mut void, src.ptr as &void, src.len * size_of::<T>());
    }

    fn copy_to<T>(src: &[T], dst: &mut T) {
        libc::memmove(dst as &mut void, src.ptr as &void, src.len * size_of::<T>());
    }

    fn free<T>(a: &mut [T]) {
        libc::free(a.ptr as &mut void);
    }
}

mod rtti {
    #[force_inline]
    fn type_id<T>() -> usize {
        intrinsics::type_id::<T>()
    }
}

mod libc {
    extern "C" fn free(ptr: &mut void);
    extern "C" fn memcpy(dst: &mut void, src: &void, len: usize) -> &mut void;
    extern "C" fn memmove(dst: &mut void, src: &void, len: usize) -> &mut void;
    extern "C" fn memcmp(ptr1: &void, ptr2: &void, len: usize) -> i32;
    extern "C" fn write(fd: i32, buf: &void, len: usize) -> isize;
    extern "C" fn malloc(size: usize) -> &mut void;
    extern "C" fn calloc(num: usize, size: usize) -> &mut void;
    extern "C" fn _exit(ret: i32) -> !;
    extern "C" fn getrandom(buf: &mut void, buflen: usize, flags: u32) -> isize;
}

mod fmt {
    protocol Formatter<Self> {
        fn write(self: &mut Self, buf: &[u8]);
    }

    protocol Formattable<Self, F: Formatter<F>> {
        fn fmt(self: &Self, f: &mut F);
    }

    mod internal {
        // Type-erased wrapper of a formattable object
        struct _FormatArg<F: Formatter<F>> {
            inner: &void,
            format_func: fn(&void, &mut F)
        }

        fn _fmt_func<F: Formatter<F>, T: Formattable<T, F>>(ptr: &void, f: &mut F) {
            T::fmt(ptr as &T, f);
        }

        impl _FormatArg {
            fn new<F: Formatter<F>, T: Formattable<T, F>>(inner: &T) -> _FormatArg<F> {
                _FormatArg::<F> {
                    inner: inner as &void,
                    format_func: _fmt_func::<F, T>,
                }
            }

            fn fmt<F: Formatter<F>>(self: &_FormatArg<F>, f: &mut F) {
                self.format_func(self.inner, f)
            }
        }

        fn format_integer<T: proto::Integer, F: Formatter<F>>(val: T, fmt: &mut F) {
            let buf: [u8; 40];
            let buf: &mut [u8] = &buf;
        
            let i: usize = buf.len - 1;
            let negative = val < 0;
            val = math::abs(val);

            loop {
                buf[i] = (val % 10) as u8 + '0';
                val /= 10;
                if val == 0 {
                    if negative {
                        i -= 1;
                        buf[i] = '-';
                    }
                    fmt.write(buf[i..]);
                    break;
                }
                i -= 1;
            }
        }

        fn format_float<T: proto::FloatingPoint, F: Formatter<F>>(val: T, fmt: &mut F, precision: usize) {
            let trunc = val as i128;
            format_integer(trunc, fmt);
            fmt.write(".");

            let frac = math::abs((val - (trunc as T)));
            
            let buf: [u8; 16];
            let buf: &mut [u8] = &buf;
            
            let i = 0usize;
            while i < precision {
                frac *= 10.0;
                let digit = frac as u8;
                buf[i] = digit + '0';
                frac -= digit as T;
                i += 1;
            }

            fmt.write(buf[..precision]);
        }

        enum State {
            NORMAL,
            BRACE_OPEN,
            BRACE_CLOSE,
        }
        
        fn printf<F: Formatter<F>>(fmt: &[u8], args: &[_FormatArg<F>], formatter: &mut F) {
            let i = 0usize;
            let buf: [u8; 64];
            let buf: &mut [u8] = &buf;

            let buf_pos = 0usize;

            macro arg() {
                if args.len == 0 {
                    panic!("too few arguments");
                }
                let arg = args[0];
                args = args[1..];
                arg
            } 

            macro buf_append(val) {
                buf[buf_pos] = val;
                buf_pos += 1;
                if buf_pos == buf.len {
                    formatter.write(buf);
                    buf_pos = 0;
                }
            }
            
            let state = State::NORMAL;
        
            while i < fmt.len {
                let ch = fmt[i];
                state = switch state {
                    State::NORMAL => {
                        switch ch {
                            '{' => State::BRACE_OPEN,
                            '}' => State::BRACE_CLOSE,
                            _ => {
                                buf_append!(ch);
                                State::NORMAL
                            }
                        }
                    }
                    State::BRACE_CLOSE => {
                        switch ch {
                        '}' => {
                                buf_append!(ch);
                            }
                            _ => panic!("invalid format string")
                        };
                        State::NORMAL
                    }
                    State::BRACE_OPEN => {
                        switch ch {
                            '}' => {
                                formatter.write(buf[0..buf_pos]);
                                (arg!()).fmt(formatter);
                                buf_pos = 0;
                            }
                            '{' => {
                                buf_append!(ch);
                            }
                            _ => panic!("invalid format string")
                        };
                        State::NORMAL
                    }
                    _ => std::intrinsics::unreachable()
                };
                i += 1;
            }

            if buf_pos > 0 {
                formatter.write(buf[0..buf_pos]);
            }
        
            if args.len > 0 {
                panic!("too many arguments");
            }
        }

        struct StringBufFormatter {
            buffer: collections::Vector<u8>
        }
        
        impl StringBufFormatter {
            fn new(size_hint: usize) -> StringBufFormatter {
                StringBufFormatter {
                    buffer: collections::Vector::with_capacity(size_hint)
                }
            }
            
            fn write(self: &mut StringBufFormatter, buf: &[u8]) {
                self.buffer.extend(buf);
            }
        }
    }

    macro write(formatter, fmt, arg...) {
        internal::printf(
            fmt, 
            &[internal::_FormatArg::new(&arg)...], 
            formatter
        )
    }

    macro writeln(formatter, fmt, arg...) {
        internal::printf(
            concat!(fmt, "\n"), 
            &[internal::_FormatArg::new(&arg)...], 
            formatter
        )
    }

    macro format(fmt, arg...) { 
        let formatter = internal::StringBufFormatter::new(fmt.len);
        fmt::write!(&formatter, fmt, arg...);
        formatter.buffer
    }
}

mod io {
    mod internal {
        struct StdIoFormatter {
            fd: i32
        }
        
        impl StdIoFormatter {
            fn new(fd: i32) -> StdIoFormatter {
                StdIoFormatter {
                    fd: fd
                }
            }
            
            fn write(self: &mut StdIoFormatter, buf: &[u8]) {
                libc::write(self.fd, buf.ptr as &void, buf.len);
            }
        }
    }

    macro print(fmt, arg...) { fmt::write!(&internal::StdIoFormatter::new(1), fmt, arg...)}
    macro println(fmt, arg...) { fmt::writeln!(&internal::StdIoFormatter::new(1), fmt, arg...)}
    macro eprint(fmt, arg...) { fmt::write!(&internal::StdIoFormatter::new(2), fmt, arg...)}
    macro eprintln(fmt, arg...) { fmt::writeln!(&internal::StdIoFormatter::new(2), fmt, arg...)}
}

mod process {
    extern "C" fn exit(v: i32) -> !;
}

mod intrinsics {
    extern "intrinsic" fn compile_fail(reason: &[u8]) -> !;
    extern "intrinsic" fn unreachable() -> !;
    extern "intrinsic" fn trap() -> !;
    extern "intrinsic" fn size_of<T>() -> usize;
    extern "intrinsic" fn type_id<T>() -> usize;
    extern "intrinsic" fn align_of<T>() -> usize;
    extern "intrinsic" fn aligned_alloca(size: usize, align: usize) -> &mut void;
}

macro panic(reason, args...) {
    io::eprintln!(
        concat!("panic at {}:{}:{} ", reason), 
        file!(), 
        line!(), 
        column!(),
        args...
    );
    libc::_exit(-1);
}

macro assert(cond) {
    if !cond {
        panic!("assertion failed");
    }
}

#[builtin] macro line() {  }
#[builtin] macro column() {  }
#[builtin] macro file() {  }
#[builtin] macro env(s) {  }
#[builtin] macro include_bytes(file) {  }
#[builtin] macro concat(parts...) {  }

mod math {
    use proto::Numeric;

    fn max<T: Numeric>(a: T, b: T) -> T {
        if a > b {
            a
        } else {
            b
        }
    }

    fn min<T: Numeric>(a: T, b: T) -> T {
        if a < b {
            a
        } else {
            b
        }
    }

    fn abs<T: Numeric>(a: T) -> T {
        if a < (0 as T) {
            (0 as T) - a
        } else {
            a
        }
    }
}

mod cmp {
    #[lang(proto_equatable)]
    protocol Equatable<Self> {
        fn equals(lhs: &Self, rhs: &Self) -> bool {
            use std::{mem::size_of, libc::memcmp};
            memcmp(lhs as &void, rhs as &void, size_of::<Self>()) == 0
        }

        #[force_inline]
        fn not_equals(lhs: &Self, rhs: &Self) -> bool {
            !Self::equals(lhs, rhs)
        }
    }
    
    enum Ordering {
        Less = -1i8,
        Equal = 0i8,
        Greater = 1i8,
    }
    
    #[lang(proto_comparable)]
    protocol Comparable<Self: Equatable<Self>> {
        use std::{mem::size_of, libc::memcmp};

        fn compare(lhs: &Self, rhs: &Self) -> Ordering {
            let ret = memcmp(lhs as &void, rhs as &void, size_of::<Self>());
            if ret < 0 {
                Ordering::Less
            } else if ret == 0 {
                Ordering::Equal
            } else {
                Ordering::Greater
            }
        }
        
        #[force_inline]
        fn less_than(lhs: &Self, rhs: &Self) -> bool {
            Self::compare(lhs, rhs) == Ordering::Less
        }
    
        #[force_inline]
        fn less_than_or_equal(lhs: &Self, rhs: &Self) -> bool {
            Self::compare(lhs, rhs) != Ordering::Greater
        }
    
        #[force_inline]
        fn greater_than(lhs: &Self, rhs: &Self) -> bool {
            Self::compare(lhs, rhs) == Ordering::Greater
        }
    
        #[force_inline]
        fn greater_than_or_equal(lhs: &Self, rhs: &Self) -> bool {
            Self::compare(lhs, rhs) != Ordering::Less
        }
    }
}

mod hash {
    protocol Hasher<Self> {
        use std::mem::{size_of,slice::from_raw};
    
        fn new() -> Self;
        fn write(self: &mut Self, val: &[u8]);
        fn finish(self: &mut Self) -> u64;
    }
    
    protocol Hashable<Self, H: Hasher<H>> {
        #[inline]
        fn hash(a: &Self, hasher: &mut H) {
            use std::mem::{size_of,slice::from_raw};
            hasher.write(from_raw(a as &u8, size_of::<Self>()));
        }
    }
}

mod util {
    #[force_inline]
    fn identity<T>(t: T) -> T { t }
}

mod iter {
    use proto::Integer;
    use result::Option;

    protocol Iterator<Self, T> {
        fn next(self: &mut Self) -> result::Option<T>;
        fn iter(self: &mut Self) -> &mut Self {
            self
        }
    }

    protocol Iterable<Self, It: Iterator<It, T>, T> {
        fn iter(self: Self) -> It;
    }

    struct Range<T: Integer> {
        lower: T,
        upper: T,
    }

    impl Range<T: Integer> {
        #[force_inline]
        fn iter(self: &Range<T>) -> RangeIter<T> {
            RangeIter {
                current: self.lower,
                upper: self.upper,
            }
        }
    }

    struct RangeIter<T: Integer> {
        current: T,
        upper: T,
    }
    
    impl RangeIter<T: Integer> {
        #[force_inline]
        fn next(self: &mut RangeIter<T>) -> Option<T> {
            if self.current < self.upper {
                let current = self.current;
                self.current += 1;
                Option::some(current)
            } else {
                Option::none()
            }
        }
        
        mixin<T: Integer> Iterator<RangeIter<T>, T>;
    }
    
    #[force_inline]
    fn range<T: Integer>(lower: T, upper: T) -> Range<T> {
        Range {
            lower: lower,
            upper: upper,
        }
    }

    fn for_each<T, I: Iterator<I, T>>(iterator: &mut I, func: fn(T)) {
        loop {
            let elem = iterator.next();
            if elem.is_some {
                func(elem.inner);
            } else {
                break;
            }
        }
    }
}
