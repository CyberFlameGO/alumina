mod mem {
    #[lang(slice)]
    struct slice<Ptr> {
        ptr: Ptr,
        len: usize,
    }
    
    impl slice {
        #[force_inline]
        #[lang(slice_new)]
        fn from_raw<Ptr>(ptr: Ptr, len: usize) -> slice<Ptr> {
            slice::<Ptr> { ptr: ptr, len: len }
        }
    }

    mod _internal {
        #[lang(slice_equal)]
        fn slice_equal<T>(a: &[T], b: &[T]) -> bool {
            use std::libc::memcmp;
            if a.len != b.len {
                return false;
            }
            memcmp(a.ptr as &(), b.ptr as &(), a.len * size_of::<T>()) == 0
        }
    
        #[force_inline]
        #[lang(slice_index)]
        fn slice_index<Ptr>(a: slice<Ptr>, idx: usize) -> Ptr {
            a.ptr + idx
        }
        
        #[force_inline]
        #[lang(slice_range_index)]
        fn slice_range_index<Ptr>(a: slice<Ptr>, lower: usize, upper: usize) -> slice<Ptr> {
            slice::from_raw::<Ptr>(a.ptr + lower, upper - lower)
        }

        #[force_inline]
        #[lang(slice_range_index_lower)]
        fn slice_range_index_lower<Ptr>(a: slice<Ptr>, lower: usize) -> slice<Ptr> {
            slice::from_raw::<Ptr>(a.ptr + lower, a.len - lower)
        }        

        #[force_inline]
        #[lang(slice_coerce)]
        fn slice_coerce<T>(a: slice<&mut T>) -> slice<&T> {
            slice::from_raw::<&T>(a.ptr, a.len)
        }
    }
    
    fn alloc<T>(len: usize) -> &mut [T] {
        let ret: &mut [T];
        ret.ptr = libc::malloc(size_of::<T>() * len) as &mut T;
        ret.len = len;
        ret
    }

    #[force_inline]
    fn stack_alloc<T>(len: usize) -> &mut [T] {
        let ret: &mut [T];
        ret.ptr = intrinsics::aligned_alloca(size_of::<T>() * len, 16usize) as &mut T;
        ret.len = len;
        ret
    }

    #[force_inline]
    fn size_of<T>() -> usize {
        intrinsics::size_of::<T>()
    }

    #[force_inline]
    fn align_of<T>() -> usize {
        intrinsics::align_of::<T>()
    }

    fn swap<T>(a: &mut T, b: &mut T) {
        let tmp = *a;
        *a = *b;
        *b = tmp;
    }

    fn copy_to<T>(src: &[T], dst: &mut T) {
        libc::memcpy(dst as &mut (), src.ptr as &(), src.len * size_of::<T>());
    }

    fn free<T>(a: &mut [T]) {
        libc::free(a.ptr as &mut ());
    }
}

mod libc {
    extern "C" fn free(ptr: &mut ());
    extern "C" fn memcpy(dst: &mut (), src: &(), len: usize) -> &mut ();
    extern "C" fn memcmp(ptr1: &(), ptr2: &(), len: usize) -> i32;
    extern "C" fn write(fd: i32, buf: &(), len: usize) -> isize;
    extern "C" fn malloc(size: usize) -> &mut ();
}

mod io {
    fn print(s: &[u8]) {
        libc::write(1, s.ptr as &(), s.len);
    }
}

mod process {
    extern fn exit(v: i32) -> !;
}

mod intrinsics {
    extern "intrinsic" fn compile_fail(reason: &[u8]) -> !;
    extern "intrinsic" fn unreachable() -> !;
    extern "intrinsic" fn size_of<T>() -> usize;
    extern "intrinsic" fn align_of<T>() -> usize;
    extern "intrinsic" fn aligned_alloca(size: usize, align: usize) -> &mut ();
}


mod math {
    fn max<T>(a: T, b: T) -> T {
        if a > b {
            a
        } else {
            b
        }
    }

    fn min<T>(a: T, b: T) -> T {
        if a < b {
            a
        } else {
            b
        }
    }

    fn abs<T>(a: T) -> T {
        if a < 0 {
            -a
        } else {
            a
        }
    }
}

mod shed {
    fn write_number<T>(val: T) {
        let buf: [u8; 16];
        let buf: &mut [u8] = &buf;
    
        let i: usize = buf.len - 1;
        let negative = val < 0;
        val = math::abs(val);

        loop {
            buf[i] = (val % 10) as u8 + 48;
            val /= 10;
            if val == 0 {
                if negative {
                    i -= 1;
                    buf[i] = '-';
                }
                std::io::print(buf[i..]);
                break;
            }
            i -= 1;
        }
    }
}
