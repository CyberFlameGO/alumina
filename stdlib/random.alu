use std::proto::Unsigned;

struct Pcg32  {
    state: u64,
    increment: u64,
}

impl Pcg32 {
    #[inline]
    fn step(self: &mut Pcg32) {
        const MUTLIPLIER = 6364136223846793005u64;
        self.state = self.state * MUTLIPLIER + self.increment;
    }

    fn from_seed(seed: u128) -> Pcg32 {
        let pcg = Pcg32 { 
            state: (seed >> 64) as u64,
            increment: (seed as u64) | 1
        };
        
        pcg.state = pcg.state + pcg.increment;
        pcg.step();
        pcg
    }

    #[inline]
    fn next_u32(self: &mut Pcg32) -> u32 {
        let state = self.state;
        self.step();
        
        const ROTATE: u32 = 59;
        const XSHIFT: u32 = 18;
        const SPARE: u32 = 27;

        let rot = (state >> ROTATE) as usize;
        let xsh = (((state >> XSHIFT) ^ state) >> SPARE) as u32;
        
        xsh.rotate_right(rot)
    }

    mixin RandomNumberGenerator<Pcg32>;
}

static DEFAULT_RNG: Pcg32 = {
    let seed: u128;
    libc::getrandom(&seed as &mut void, mem::size_of::<u128>(), 0);
    Pcg32::from_seed(seed)
};

protocol RandomNumberGenerator<Self> {
    // One of these two has to be implemented, otherwise we have infinite recursio
    #[inline]
    fn next_u32(self: &mut Self) -> u32 {
        self.next_u64() as u32
    }

    #[inline]
    fn next_u64(self: &mut Self) -> u64 {
        (self.next_u32() as u64) << 32 | (self.next_u32() as u64)
    }
}

fn range<Rng: RandomNumberGenerator<Rng>, T: Unsigned>(rng: &mut Rng, range: u32) -> u32 {
    let t: u32 = (~range + 1) % range;
    let m = loop {
        let m = (rng.next_u32() as u64) * (range as u64);
        if t <= m as u32 {
            break m
        }
    };
    (m >> 32) as u32
}

fn shuffle<Rng: RandomNumberGenerator<Rng>, T>(rng: &mut Rng, slice: &mut [T]) {
    let i = 0usize;
    while i < slice.len {
        let j = rng.range((slice.len - i) as u32) as usize;
        std::mem::swap(&slice[i], &slice[j + i]);
        i += 1;
    }
}
