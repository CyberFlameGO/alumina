protocol Formatter<Self> {
    fn write_str(self: &mut Self, buf: &[u8]);
    
    fn write_char(self: &mut Self, byte: u8) {
        self.write_str(mem::slice::from_raw(&byte, 1));
    }
}

protocol Formattable<Self, F: Formatter<F> = internal::_NullFormatter> {
    fn fmt(self: &Self, f: &mut F);
}

macro write($fmt, $fmt_str, $arg...) {
    internal::printf(
        concat!($fmt_str), 
        &[internal::FormatArg::new(&$arg)...], 
        $fmt
    )
}

macro writeln($fmt, $fmt_str, $arg...) {
    internal::printf(
        concat!($fmt_str, "\n"), 
        &[internal::FormatArg::new(&$arg)...], 
        $fmt
    )
}

macro format($fmt_str, $arg...) { 
    let fmt = collections::Vector::with_capacity::<u8>($fmt_str.len);
    fmt::write!(&fmt, $fmt_str, $arg...);
    fmt
}

macro format_in($buf, $fmt_str, $arg...) { 
    let fmt = SliceFormatter::new($buf);
    fmt::write!(&fmt, $fmt_str, $arg...);
    fmt.get()
}

struct SliceFormatter {
    buf: &mut [u8],
    buf_pos: usize
}

impl SliceFormatter {
    fn new(buf: &mut [u8]) -> SliceFormatter {
        SliceFormatter {
            buf: buf,
            buf_pos: 0
        }
    }

    #[inline]
    fn write_str(self: &mut SliceFormatter, buf: &[u8]) {
        use mem::copy_to;
        if self.buf_pos + buf.len > self.buf.len {
            panic!("buffer overflow");
        }
        buf.copy_to(&self.buf[self.buf_pos]);
        self.buf_pos += buf.len;
    }

    #[inline]
    fn write_char(self: &mut SliceFormatter, byte: u8) {
        if self.buf_pos >= self.buf.len {
            panic!("buffer overflow");
        }
        self.buf[self.buf_pos] = byte;
        self.buf_pos += 1;
    }

    #[inline]
    fn get(self: &SliceFormatter) -> &[u8] {
        self.buf[..self.buf_pos]
    }
}

struct BufferedFormatter<F: Formatter<F>> {
    buf: &mut [u8],
    buf_pos: usize,
    inner: &mut F
}

impl BufferedFormatter<F: Formatter<F>> {
    fn new(buf: &mut [u8], inner: &mut F) -> BufferedFormatter<F> {
        BufferedFormatter {
            buf: buf,
            buf_pos: 0,
            inner: inner
        }
    }

    #[inline]
    fn write_str(self: &mut BufferedFormatter<F>, buf: &[u8]) {
        use std::mem::copy_to_nonoverlapping;
        
        let fill_len = math::min(self.buf.len - self.buf_pos, buf.len);
        if fill_len > 0 {
            buf[0..fill_len].copy_to_nonoverlapping(&self.buf[self.buf_pos]);
            self.buf_pos += fill_len;
            buf = buf[fill_len..];
        }

        if self.buf_pos == self.buf.len {
            self.inner.write_str(self.buf);
            self.buf_pos = 0;
        }

        if buf.len >= self.buf.len {
            self.inner.write_str(buf);
        } else if buf.len > 0 {
            buf.copy_to_nonoverlapping(&self.buf[0]);
            self.buf_pos += buf.len;
        }
    }

    #[inline]
    fn write_char(self: &mut BufferedFormatter<F>, byte: u8) {
        if self.buf_pos == self.buf.len {
            self.inner.write_str(self.buf);
            self.buf_pos = 0;
        }

        self.buf[self.buf_pos] = byte;
        self.buf_pos += 1;
    }

    #[inline]
    fn flush(self: &mut BufferedFormatter<F>) {
        if self.buf_pos > 0 {
            self.inner.write_str(self.buf[0..self.buf_pos]);
            self.buf_pos = 0;
        }
    }
}

mod internal {
    struct _NullFormatter {}
    impl _NullFormatter {
        fn write_str(self: &mut _NullFormatter, buf: &[u8]) { }
        fn write_char(self: &mut _NullFormatter, byte: u8) {}
    }

    // Type-erased wrapper of a formattable object
    struct FormatArg<F: Formatter<F>> {
        inner: &void,
        format_func: fn(&void, &mut F)
    }

    impl FormatArg {
        fn new<F: Formatter<F>, T: Formattable<T, F>>(inner: &T) -> FormatArg<F> {
            FormatArg::<F> {
                inner: inner as &void,
                format_func: |ptr, f| T::fmt(ptr as &T, f),
            }
        }

        fn fmt<F: Formatter<F>>(self: &FormatArg<F>, f: &mut F) {
            self.format_func(self.inner, f)
        }
    }

    static DIGITS: [u8; 16] = [
        '0', '1', '2', '3', 
        '4', '5', '6', '7', 
        '8', '9', 'a', 'b',
        'c', 'd', 'e', 'f'
    ]; 

    fn format_integer<T: proto::Integer, F: Formatter<F>>(val: T, radix: u16, pad: usize, fmt: &mut F) {
        assert!(radix >= 2 && radix <= 16);
        
        let buf: [u8; 128];
        let buf = buf.as_slice_mut();
    
        
        let (negative, val) = when T: proto::Signed {
            if val < 0 {
                // If val == T::min_value(), negation overflows, so we do this trick,
                // manual 2's complement negation, but widening to the unsigned type,
                // before adding 1.
                (true, ((~val) as builtins::unsigned_of<T>) + 1)
            } else {
                (false, val as builtins::unsigned_of<T>)
            }   
        } else {
            (false, val as builtins::unsigned_of<T>)
        };

        let i: usize = 0;
        loop {
            buf[buf.len - i - 1] = DIGITS[(val % (radix as builtins::unsigned_of<T>)) as usize];
            val /= radix as builtins::unsigned_of<T>;
            
            if val == 0 {
                when T: proto::Signed {
                    if negative {
                        fmt.write_char('-');
                    }
                }
                while i + 1 < pad {
                    fmt.write_char('0');
                    pad -= 1;
                }
                fmt.write_str(buf[buf.len - i - 1..]);
                break;
            }
            i += 1;
        }
    }

    fn format_float<T: proto::FloatingPoint, F: Formatter<F>>(val: T, fmt: &mut F, precision: usize) {
        let trunc = val as i128;
        format_integer(trunc, 10, 0, fmt);
        fmt.write_char('.');

        let frac = math::abs((val - (trunc as T)));
        
        let buf: [u8; 16];
        let buf = buf.as_slice_mut();
        
        let i = 0usize;
        while i < precision {
            frac *= 10.0;
            let digit = frac as u8;
            buf[i] = digit + '0';
            frac -= digit as T;
            i += 1;
        }

        fmt.write_str(buf[..precision]);
    }

    enum State {
        NORMAL,
        BRACE_OPEN,
        BRACE_CLOSE,
    }
    
    fn printf<F: Formatter<F>>(fmt_str: &[u8], args: &[FormatArg<F>], fmt: &mut F) {
        let i = 0usize;

        let state = State::NORMAL;
        while i < fmt_str.len {
            let ch = fmt_str[i];
            state = switch state {
                State::NORMAL => {
                    switch ch {
                        '{' => State::BRACE_OPEN,
                        '}' => State::BRACE_CLOSE,
                        _ => {
                            fmt.write_char(ch);
                            State::NORMAL
                        }
                    }
                }
                State::BRACE_CLOSE => {
                    switch ch {
                        '}' => fmt.write_char(ch),
                        _ => panic!("invalid format string")
                    };
                    State::NORMAL
                }
                State::BRACE_OPEN => {
                    switch ch {
                        '}' => {
                            if args.len == 0 {
                                panic!("too few arguments");
                            }
                            args[0].fmt(fmt);
                            args = args[1..];
                        },
                        '{' => fmt.write_char(ch),
                        _ => panic!("invalid format string")
                    };
                    State::NORMAL
                }
                _ => std::intrinsics::unreachable()
            };
            i += 1;
        }

        if state != State::NORMAL {
            panic!("invalid format string");
        }

        if args.len > 0 {
            panic!("too many arguments");
        }
    }

    struct NumFormatAdapter<T: proto::Unsigned> {
        radix: u16,
        _pad: usize,
        value: T
    }

    impl NumFormatAdapter<T: proto::Unsigned> {
        fn fmt<F: Formatter<F>>(self: &NumFormatAdapter<T>, fmt: &mut F) {
            format_integer(self.value, self.radix, self._pad, fmt);
        }

        fn hex(self: NumFormatAdapter<T>) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: 16, _pad: self._pad, value: self.value }
        }

        fn oct(self: NumFormatAdapter<T>) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: 8, _pad: self._pad, value: self.value }
        }

        fn bin(self: NumFormatAdapter<T>) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: 2, _pad: self._pad, value: self.value }
        }

        fn pad(self: NumFormatAdapter<T>, pad: usize) -> NumFormatAdapter<T> {
            NumFormatAdapter { radix: self.radix, _pad: pad, value: self.value }
        }
    }

    struct RepeatAdapter<T: Formattable<T>> {
        times: usize,
        inner: T
    }

    impl RepeatAdapter {
        fn fmt<T: Formattable<T, F>, F: Formatter<F>>(self: &RepeatAdapter<T>, fmt: &mut F) {
            for i in range(0usize, self.times) {
                self.inner.fmt(fmt);
            }
        }
    }
}

fn hex<T: proto::Unsigned>(val: T) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 16, _pad: 0, value: val }
}

fn bin<T: proto::Unsigned>(val: T) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 2, _pad: 0, value: val }
}

fn oct<T: proto::Unsigned>(val: T) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 8, _pad: 0, value: val }
}

fn pad<T: proto::Unsigned>(val: T, pad: usize) -> internal::NumFormatAdapter<T> {
    internal::NumFormatAdapter { radix: 10, _pad: pad, value: val }
}

fn repeat<T: Formattable<T>>(times: usize, inner: T) -> internal::RepeatAdapter<T> {
    internal::RepeatAdapter { times: times, inner: inner }
}


#[cfg(test)]
mod tests {
    static BUF: [u8; 1024];
    
    #[test]
    fn test_format_integer() {
        assert_eq!(format_in!(&BUF, "{}", u8::max_value()), "255");
        assert_eq!(format_in!(&BUF, "{}", -23847), "-23847");
        assert_eq!(format_in!(&BUF, "{}", i64::min_value()), "-9223372036854775808");
        assert_eq!(
            format_in!(&BUF, "{}", i128::min_value()), 
            "-170141183460469231731687303715884105728"
        );
    }

    #[test]
    fn test_format_radix() {
        assert_eq!(format_in!(&BUF, "{}", 255u32.hex()), "ff");
        assert_eq!(format_in!(&BUF, "{}", 255u32.bin()), "11111111");
        assert_eq!(format_in!(&BUF, "{}", 255u32.oct()), "377");
    }

    #[test]
    fn test_format_zero_pad() {
        assert_eq!(format_in!(&BUF, "{}", 255u32.pad(4)), "0255");
        assert_eq!(format_in!(&BUF, "{}", 255u32.pad(8)), "00000255");
    }

    #[test]
    fn test_format_radix_and_pad() {
        assert_eq!(format_in!(&BUF, "{}", 15u8.pad(2).hex()), "0f");
        assert_eq!(format_in!(&BUF, "{}", 15u8.hex().pad(2)), "0f");
    }

    #[test]
    fn test_format_repeat() {
        assert_eq!(format_in!(&BUF, "{}", repeat(3, "world")), "worldworldworld");
    }
}
