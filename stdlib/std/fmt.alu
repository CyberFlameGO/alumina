protocol Formatter<Self> {
    fn write(self: &mut Self, buf: &[u8]);
    
    fn write_byte(self: &mut Self, byte: u8) {
        self.write(mem::slice::from_raw(&byte, 1));
    }
}

protocol Formattable<Self, F: Formatter<F>> {
    fn fmt(self: &Self, f: &mut F);
}

macro write(fmt, fmt_str, arg...) {
    internal::printf(
        concat!(fmt_str), 
        &[internal::_FormatArg::new(&arg)...], 
        fmt
    )
}

macro writeln(fmt, fmt_str, arg...) {
    internal::printf(
        concat!(fmt_str, "\n"), 
        &[internal::_FormatArg::new(&arg)...], 
        fmt
    )
}

macro format(fmt_str, arg...) { 
    let fmt = StringBufFormatter::new(fmt_str.len * 2);
    fmt::write!(&fmt, fmt_str, arg...);
    fmt.buffer
}

struct BufferedFormatter<F: Formatter<F>> {
    buf: &mut [u8],
    buf_pos: usize,
    inner: &mut F
}

impl BufferedFormatter<F: Formatter<F>> {
    fn new(buf: &mut [u8], inner: &mut F) -> BufferedFormatter<F> {
        BufferedFormatter {
            buf: buf,
            buf_pos: 0,
            inner: inner
        }
    }

    #[inline]
    fn write(self: &mut BufferedFormatter<F>, buf: &[u8]) {
        use std::mem::copy_to_nonoverlapping;
        
        let fill_len = math::min(self.buf.len - self.buf_pos, buf.len);
        if fill_len > 0 {
            buf[0..fill_len].copy_to_nonoverlapping(&self.buf[self.buf_pos]);
            self.buf_pos += fill_len;
            buf = buf[fill_len..];
        }

        if self.buf_pos == self.buf.len {
            self.inner.write(self.buf);
            self.buf_pos = 0;
        }

        if buf.len >= self.buf.len {
            self.inner.write(buf);
        } else if buf.len > 0 {
            buf.copy_to_nonoverlapping(&self.buf[0]);
            self.buf_pos += buf.len;
        }
    }

    #[inline]
    fn write_byte(self: &mut BufferedFormatter<F>, byte: u8) {
        if self.buf_pos == self.buf.len {
            self.inner.write(self.buf);
            self.buf_pos = 0;
        }

        self.buf[self.buf_pos] = byte;
        self.buf_pos += 1;
    }

    #[inline]
    fn flush(self: &mut BufferedFormatter<F>) {
        if self.buf_pos > 0 {
            self.inner.write(self.buf[0..self.buf_pos]);
            self.buf_pos = 0;
        }
    }
}

struct StringBufFormatter {
    buffer: collections::Vector<u8>
}

impl StringBufFormatter {
    fn new(size_hint: usize) -> StringBufFormatter {
        StringBufFormatter {
            buffer: collections::Vector::with_capacity(size_hint)
        }
    }

    #[inline]
    fn write(self: &mut StringBufFormatter, buf: &[u8]) {
        self.buffer.extend_from_slice(buf);
    }

    #[inline]
    fn write_byte(self: &mut StringBufFormatter, byte: u8) {
        self.buffer.push(byte);
    }
}

mod internal {
    // Type-erased wrapper of a formattable object
    struct _FormatArg<F: Formatter<F>> {
        inner: &void,
        format_func: fn(&void, &mut F)
    }

    impl _FormatArg {
        fn new<F: Formatter<F>, T: Formattable<T, F>>(inner: &T) -> _FormatArg<F> {
            _FormatArg::<F> {
                inner: inner as &void,
                format_func: |ptr, f| T::fmt(ptr as &T, f),
            }
        }

        fn fmt<F: Formatter<F>>(self: &_FormatArg<F>, f: &mut F) {
            self.format_func(self.inner, f)
        }
    }

    fn format_integer<T: proto::Integer, F: Formatter<F>>(val: T, fmt: &mut F) {
        let buf: [u8; 40];
        let buf = buf.as_slice_mut();
    
        let i: usize = buf.len - 1;
        let negative = val < 0;
        val = math::abs(val);

        loop {
            buf[i] = (val % 10) as u8 + '0';
            val /= 10;
            if val == 0 {
                if negative {
                    i -= 1;
                    buf[i] = '-';
                }
                fmt.write(buf[i..]);
                break;
            }
            i -= 1;
        }
    }

    fn format_float<T: proto::FloatingPoint, F: Formatter<F>>(val: T, fmt: &mut F, precision: usize) {
        let trunc = val as i128;
        format_integer(trunc, fmt);
        fmt.write(".");

        let frac = math::abs((val - (trunc as T)));
        
        let buf: [u8; 16];
        let buf = buf.as_slice_mut();
        
        let i = 0usize;
        while i < precision {
            frac *= 10.0;
            let digit = frac as u8;
            buf[i] = digit + '0';
            frac -= digit as T;
            i += 1;
        }

        fmt.write(buf[..precision]);
    }

    enum State {
        NORMAL,
        BRACE_OPEN,
        BRACE_CLOSE,
    }
    
    fn printf<F: Formatter<F>>(fmt_str: &[u8], args: &[_FormatArg<F>], fmt: &mut F) {
        let i = 0usize;

        let state = State::NORMAL;
        while i < fmt_str.len {
            let ch = fmt_str[i];
            state = switch state {
                State::NORMAL => {
                    switch ch {
                        '{' => State::BRACE_OPEN,
                        '}' => State::BRACE_CLOSE,
                        _ => {
                            fmt.write_byte(ch);
                            State::NORMAL
                        }
                    }
                }
                State::BRACE_CLOSE => {
                    switch ch {
                        '}' => fmt.write_byte(ch),
                        _ => panic!("invalid format string")
                    };
                    State::NORMAL
                }
                State::BRACE_OPEN => {
                    switch ch {
                        '}' => {
                            if args.len == 0 {
                                panic!("too few arguments");
                            }
                            args[0].fmt(fmt);
                            args = args[1..];
                        },
                        '{' => fmt.write_byte(ch),
                        _ => panic!("invalid format string")
                    };
                    State::NORMAL
                }
                _ => std::intrinsics::unreachable()
            };
            i += 1;
        }

        if state != State::NORMAL {
            panic!("invalid format string");
        }

        if args.len > 0 {
            panic!("too many arguments");
        }
    }
}
