use std::fmt::{write, Formatter};

macro try(opt) {
    let opt = opt;
    if opt.is_some {
        opt.inner
    } else {
        return Option::none()
    }
}

struct Option<T> {
    is_some: bool,
    inner: T
}

impl Option<T> {
    #[force_inline]
    fn some(inner: T) -> Option<T> {
        Option::<T> {
            is_some: true, 
            inner: inner
        }
    }

    #[force_inline]
    fn none() -> Option<T> {
        Option::<T> {
            is_some: false
        }
    }

    fn as_result<E>(self: Option<T>, err: E) -> result::Result<T, E> {
        if self.is_some {
            result::Result::ok(self.inner)
        } else {
            result::Result::err(err)
        }
    }

    fn unwrap(self: Option<T>) -> T {
        if self.is_some {
            self.inner
        } else {
            panic!("unwrap on a none value")
        }
    }

    fn unwrap_or(self: Option<T>, val: T) -> T {
        if self.is_some {
            self.inner
        } else {
            val
        }
    }

    fn iter(self: &Option<T>) -> Option<T> {
        *self
    }

    fn next(self: &mut Option<T>) -> Option<T> {
        std::mem::replace(self, Option::none())
    }

    fn fmt<F: Formatter<F>>(self: &Option<T>, formatter: &mut F) {
        if self.is_some {
            write!(formatter, "some({})", self.inner)
        } else {
            write!(formatter, "none")
        }
    }
}
