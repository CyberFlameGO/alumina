use std::string::StringBuf;
use std::fmt::{Formatter, Formattable, Result, write, Error};

enum State {
    Normal,
    MaybeItalic,
    Italic,
    BoldEnd,
    Bold,
    Code,
    LinkTitle,
    LinkUrlStart,
    LinkUrl,
}

struct InlineMarkdownState {
    kind: State,
    link_text: StringBuf,
    link_url: StringBuf,
}

impl InlineMarkdownState {
    fn default() -> InlineMarkdownState {
        InlineMarkdownState {
            kind: State::Normal,
            link_text: StringBuf::new(),
            link_url: StringBuf::new()
        }
    }

    fn reset(self: &mut InlineMarkdownState) -> ::Result<(), ()> {
        if self.kind != State::Normal {
            return Result::err(())
        } 
        self.free();
        *self = InlineMarkdownState::default();
        Result::ok(())
    }

    fn move(self: &mut InlineMarkdownState) -> InlineMarkdownState {
        InlineMarkdownState { 
            kind: self.kind, 
            link_text: self.link_text.move(),
            link_url: self.link_url.move()
        }
    }

    fn free(self: &mut InlineMarkdownState) {
        self.link_text.free();
        self.link_url.free();
    }
}

/// A very tiny subset of Markdown is supported, just inline code, bold, italic and links
/// without nesting. 
struct InlineMarkdown {
    inner: &[u8],
    state: &mut InlineMarkdownState,
}

impl InlineMarkdown {
    fn new(inner: &[u8], state: &mut InlineMarkdownState) -> InlineMarkdown {
        InlineMarkdown {
            inner: inner,
            state: state
        }
    }

    fn fmt<F: Formatter<F>>(self: &InlineMarkdown, f: &mut F) -> Result {
        for ch in self.inner {
            switch self.state.kind {
                State::Normal => switch ch {
                    '*' => self.state.kind = State::MaybeItalic,
                    '`' => {
                        write!(f, "<code>")?;
                        self.state.kind = State::Code;
                    },
                    '[' => self.state.kind = State::LinkTitle,
                    _ => f.write_char(ch)?,
                },
                State::MaybeItalic => switch ch {
                    '*' => {
                        self.state.kind = State::Bold;
                        write!(f, "<b>")?;
                    }
                    _ => {
                        self.state.kind = State::Italic;
                        write!(f, "<i>")?;
                        f.write_char(ch)?;
                    }
                },
                State::Italic => switch ch {
                    '*' => {
                        write!(f, "</i>")?;
                        self.state.kind = State::Normal;
                    },
                    _ => f.write_char(ch)?,
                },
                State::Bold => switch ch {
                    '*' => {
                        write!(f, "</b>")?;
                        self.state.kind = State::BoldEnd;
                    },
                    _ => f.write_char(ch)?,
                },
                State::BoldEnd => switch ch {
                    '*' => {
                        self.state.kind = State::Normal;
                    },
                    _ => return Result::err(Error::new())
                },
                State::Code => switch ch {
                    '`' => {
                        write!(f, "</code>")?;
                        self.state.kind = State::Normal;
                    },
                    _ => f.write_char(ch)?,
                },
                State::LinkTitle => switch ch {
                    ']' => self.state.kind = State::LinkUrlStart,
                    _ => self.state.link_text.push(ch),
                },
                State::LinkUrlStart => switch ch {
                    '(' => self.state.kind = State::LinkUrl,
                    _ => return Result::err(Error::new()),
                },
                State::LinkUrl => switch ch {
                    ')' => {
                        write!(f, 
                            "<a href=\"{}\">{}</a>", 
                            self.state.link_url.as_slice(), 
                            self.state.link_text.as_slice()
                        )?;
                        self.state.kind = State::Normal;
                    },
                    _ => self.state.link_url.push(ch),
                },
            }
        }

        Result::ok(())
    }
}
