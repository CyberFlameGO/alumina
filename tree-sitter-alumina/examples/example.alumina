
mod foo {
    struct foo {

    }
}

enum type_let {
    FOO,
    BAR,
}

type_let::FOO


#[lang_item(slice)]
struct slice<T> {
    ptr: &T,
    len: usize,
}

#[lang_item(str)]
type str = slice<u8>;

fn alloc<T>(n: usize) -> [T] {

}

fn sum(values: [u64]) -> u64 {
    let sum: u64 = 0;
    for let i: usize = 0; i < values.len; i += 1 {
        sum += *(values.ptr + i);
    }
    sum
}

struct foo {
    a: i32,
    b: i32,
    fn_ptr: &fn(i32) -> i32,
}

struct templ<T> {
    a: T,
    f: fn(T) -> u32
}

macro print {

}


fn strcat(a: slice, b: slice) -> slice {
    let new: &u8 = malloc(a.size + b.size);
    memcpy(new, a.ptr, a.size);
    memcpy(new + a.size, b.ptr, b.size);
    new
}

struct foo {
    arr: [u32; 10],
    fn_ptr: &fn(i32) -> i32,
}

fn malloc(n: usize) -> &void {
    ...
}

fn malloc(n: usize) -> (u32, u32) {
    ...
}

fn openfile(filename: slice) -> (fp, &err) {
    ...
}

fn free(p: &void)

fn panic() -> ! {
    loop {}
}

fn associated_function(c: &foo) {
    c->a = 3;
}

fn take_struct(s: foo) -> foo {
    a.a = 1;
    s.b = 2; 
    s
}

fn take_struct_by_pointer(s: &foo) -> void {
    a = 1;
    s->b = 2; 
}

struct vector<T> {
    data: [T],
    capacity: usize,
}

impl vector<T> {
    fn new(capacity: usize) -> vector<T> {
        vector::<T> {
            data: slice::<T> {
                ptr: malloc(size_of::<T>() * capacity),
                len: 0,
            },
            capacity: capacity,
        }
    }

    fn free(self: &vector<T>) {
        free(self.data);
    }

    fn grow(self: &vector<T>) {
        let new_capacity: usize = (self.capacity + 1) * 2;
        let new_data: &T = malloc(new_capacity * size_of::<T>()) as &T;
        memcpy(new_data, self.data, self.len);
        free(self.data);

        self.data = new_vector.data;
        self.capacity = new_capacity;
    }

    fn append(self: &vector<T>)  {
        if self.len == self.capacity {
            self.grow();
        }

        vector.data[vector.len] = val;
        vector.len += 1;
    }
}

fn main() {
    let vector = vector::<u8>::new(10);
    vector.append(0x00);
    vector.append(0x01);
    vector.append(0x02);
    vector.data[i] = 0x03;

    vector.free();
}

fn main() {
    let a: &u32;
    let b: [u8; 5] = { 1, 2, 3, 4, 5 };

    // arrays coerce to slices, so they can be passed to functions that take slices
    

    *(0x3282379823 as &u8) = 15;

    let foo, bar: &u32;

    a = {
        let c: &u32;
        c + 1
    };

    a = &b[0];

    let (fp, err) = openfile("foo.txt");
    if err != nil {

    }

    let ptr = &take_struct_by_pointer;

    let f: foo;
    f.a = 1;
    f.b = 2;

    f.associated_function();
    
    for a = 0, a < 15, a += 1 {
        b[i] = 1;
    }
}
