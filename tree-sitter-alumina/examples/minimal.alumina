struct vector<T> {
    data: [T],
    capacity: usize,
}

impl vector<T> {
    fn new(capacity: usize) -> vector<T> {
        vector::<T> {
            data: slice::<T> {
                ptr: malloc(size_of::<T>() * capacity),
                len: 0,
            },
            capacity: capacity,
        }
    }

    fn free(self: &vector<T>) {
        free(self.data);
    }

    fn grow(self: &vector<T>) {
        let new_capacity: usize = (self.capacity + 1) * 2;
        let new_data: &T = malloc(new_capacity * size_of::<T>()) as &T;
        memcpy(new_data, self.data, self.len);
        free(self.data);

        self.data = new_vector.data;
        self.capacity = new_capacity;
    }

    fn append(self: &vector<T>)  {
        if self.len == self.capacity {
            self.grow();
        }

        vector.data[vector.len] = val;
        vector.len += 1;
    }
}

fn main() {
    let vector = vector::<u8>::new(10);
    vector.append(0x00);
    vector.append(0x01);
    vector.append(0x02);
    vector.data[i] = 0x03;

    vector.free();
}
